;;; The implementation of the component tree for gray-level images.

(ns clj-ctree.core
  (:use  clj-ctree.vectors
		 clj-ctree.polynomial
		 clj-ctree.image
		 clj-ctree.utils				; dbg, seq2redundant-map
		 clojure.set
		 clojure.contrib.pprint
		 ))

(defn bin-by-intensity
  "Given an image (arg1) bin-by-intensity returns an intensity map of the image, in which
each intensity value is represented by a key (sorted in decreasing order), followed by a list
of offsets corresponding to each intensity value."
  [image]
  (letfn [(key-value-pair [x] (vector (get-pixel image x) x))]
	(seq2redundant-map (range (get-size image)) key-value-pair conj :sort-down)))


(defn make-ctree
  "Given an image (arg1) and a maximum Hamming radius (arg2), make-ctree generates and returns
a component tree for the image, consisting of a map with integer keys, corresponding to a decreasing
sequence of image intensities, with corresponding values consisting of lists of sets of the
topologically connected components with intensities equal to or greater than each intensity threshold."
  ([image max-hamming-radius min-intensity]
	 (let [bins (filter #(>= (first %) min-intensity) (bin-by-intensity image))
		   kernel (get-neighborhood-mask (get-dimensionality image) max-hamming-radius)
		   k-values (keys bins)]
	   (letfn [(get-intensity
				[offset]
				(nth (:raster image) offset))

			   (get-bright-neighbors
				[offset]
				(let [threshold (get-intensity offset)
					  value (get-filtered-neighborhood image kernel #(<= threshold %1) offset)]
				  (dbg :make-ctree-gbn "(get-bright-neighbors ~a) => ~s~%" offset value)
				  value))

			   (collect-components
				[active-sets offset]
				(let [neighbors (into #{} (get-bright-neighbors offset))]
				  (dbg :make-ctree-cc "active-sets-> ~a, offset-> ~a:~%" active-sets offset)
				  (loop [open-sets active-sets current-set (into #{} (list offset)) other-sets ()]
					(if (empty? open-sets)
					  (conj other-sets current-set)
					  (let [aset (first open-sets),
							[new-current-set new-other-sets] (if (empty? (intersection neighbors aset))
															   (vector current-set (conj other-sets aset))
															   (vector (union aset current-set) other-sets))]
						(dbg-indent :make-ctree-cc 1 "(intersection ~a ~a) => ~a"
									neighbors aset (intersection neighbors aset))
						(dbg-indent :make-ctree-cc 1 "aset-> ~a, new-current-set-> ~a, new-other-sets -> ~a~%"
									aset new-current-set new-other-sets)
						(recur (rest open-sets) new-current-set new-other-sets))))))
			   ]
		 (loop [ctree (sorted-map-by #(compare %2 %1)) b bins]
		   (if (empty? b)
			 ctree
			 (let [[k offsets] (first b),
				   k-sets (reduce #(collect-components %1 %2)
								  (get ctree (least-above k k-values))
								  offsets)]
			   (recur (merge ctree (into {} (list (vector k k-sets)))) (rest b))
			   ))))))
  ([image max-hamming-radius] (make-ctree image max-hamming-radius 0)))

(defn analyze-ctree
  "Given a component tree (arg1), as generated by make-ctree, analyze-ctree generates a new map,
with integer-valued keys, corresponding the intensities of the component tree, followed by a list
of integers that correspond to the size of each component."
  [ctree]
  (into (sorted-map-by #(compare %2 %1))
		(for [[k v] ctree]
		  (vector k (map count v)))))

